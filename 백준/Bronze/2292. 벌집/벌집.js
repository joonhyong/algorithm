// 백준 2292번 벌집
// 분류 : 수학
/*입력예제
13
*/
/*유도코드
벌집의 중앙은 1이다. 이곳을 area 0으로 볼 때, 
그 주변을 감싸고 있는 범위는 area 1,
그 주변을 감싸고 있는 범위는 area 2,
... 라고 하자.

area = 0 인 부분은 n===1 인 경우이고,
area = 1 인 부분은 n>=2 && n<=7인 경우이고,
area = 2 인 부분은 n>=8 && n<=19인 경우이고,
area = 3 인 부분은 n>=20 && n<=37인 경우이고,
... 를 반복한다.
즉, n <= "어떤수" 부분에서 "어떤수"는 area가 1 증가할 때 마다 그 전의 "어떤수"에서 6씩 증가한다. 

area를 1씩 증가시키며 n이 해당 범위의 최솟값 이상, 최댓값 이하의 범위에 속하는지 확인해야하는데,
area를 1 증가 시킨다는 것은 이미 그 전 범위의 최댓값보다 크다는 뜻이므로,
범위에 속하는지 확인할 때는 해당 area의 최댓값 이하인지만 확인하면 된다.

while문에서 area = 0부터 확인을 해보며,
범위에 속한다면 cnt++ 후 break를 하고
범위에 속하지 않는다면 cnt++ 후 area++를 한다. 
-> 범위에 속하지 않는데도 cnt++ 하는 이유는 다음 area를 갈때 현재 area를 밟고 가야하므로 이동량을 증가시켜 주어야한다. 
-> 같은 이유로 n===1일땐 cnt++후 break되어 정답으로 1이 출력되고, n>1인 경우에도 area=0(n===1)을 밟으면서 cnt++하며 이동량을 카운팅한다.
*/
/* 알게 된 점 + 공부해야 할 점
n에 대한 범위를 측정할때, 최솟값 <= n <= 최댓값과 같이 2번의 확인이 필요하다.
이 때, 시작점(해당 문제에서는 1)을 기준으로 최솟값, 최댓값 각각에 대한 점화식이 필요하므로 범위 마다 2개의 점화식이 필요하다.
하지만 범위 속하는지 확인하고 속하지 않는다면 다음 범위로 넘어가는데, 범위에 속하지 않는다는 것은 `n > 해당 area의 최댓값`이라는 것이므로
다음 범위에 대해 확인할 때는 `n <= 다음 area의 최댓값`만 확인하면 된다. 즉, 최댓값에 대한 점화식만 계산하면 되는 것이다.
*/

const fs = require("fs");
const file = process.platform === "linux" ? "/dev/stdin" : "../exam.txt";
const input = fs.readFileSync(file).toString().trim().split("\n");

const n = Number(input.shift());

let area = 0; // area 단계를 알려주는 변수
let cnt = 0; // 정답 변수
let max = 1; // area 0의 최댓값을 기억해두는 변수
while (1) {
  max += area * 6;
  if (n <= max) {
    cnt++;
    break;
  }
  cnt++;
  area++;
}

console.log(cnt);
